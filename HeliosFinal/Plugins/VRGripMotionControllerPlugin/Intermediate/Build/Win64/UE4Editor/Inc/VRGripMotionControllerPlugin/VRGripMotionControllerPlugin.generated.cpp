// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Private/VRGripMotionControllerPluginPrivatePCH.h"
#include "VRGripMotionControllerPlugin.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeVRGripMotionControllerPlugin() {}
class UScriptStruct* FBPActorGripInformation::StaticStruct()
{
	extern VRGRIPMOTIONCONTROLLERPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRGripMotionControllerPlugin();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern VRGRIPMOTIONCONTROLLERPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPActorGripInformation();
		extern VRGRIPMOTIONCONTROLLERPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FBPActorGripInformation_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FBPActorGripInformation, Z_Construct_UPackage__Script_VRGripMotionControllerPlugin(), TEXT("BPActorGripInformation"), sizeof(FBPActorGripInformation), Get_Z_Construct_UScriptStruct_FBPActorGripInformation_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FBPActorGripInformation(FBPActorGripInformation::StaticStruct, TEXT("/Script/VRGripMotionControllerPlugin"), TEXT("BPActorGripInformation"), false, nullptr, nullptr);
static struct FScriptStruct_VRGripMotionControllerPlugin_StaticRegisterNativesFBPActorGripInformation
{
	FScriptStruct_VRGripMotionControllerPlugin_StaticRegisterNativesFBPActorGripInformation()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("BPActorGripInformation")),new UScriptStruct::TCppStructOps<FBPActorGripInformation>);
	}
} ScriptStruct_VRGripMotionControllerPlugin_StaticRegisterNativesFBPActorGripInformation;
	void UGripMotionControllerComponent::StaticRegisterNativesUGripMotionControllerComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "DropActor",(Native)&UGripMotionControllerComponent::execDropActor);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GripActor",(Native)&UGripMotionControllerComponent::execGripActor);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "IsTracked",(Native)&UGripMotionControllerComponent::execIsTracked);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "PostTeleportMoveGrippedActors",(Native)&UGripMotionControllerComponent::execPostTeleportMoveGrippedActors);
	}
	IMPLEMENT_CLASS(UGripMotionControllerComponent, 2363812184);
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	ENGINE_API class UClass* Z_Construct_UClass_AActor_NoRegister();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FTransform();
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent();
	HEADMOUNTEDDISPLAY_API class UEnum* Z_Construct_UEnum_HeadMountedDisplay_ETrackingStatus();
	INPUTCORE_API class UEnum* Z_Construct_UEnum_InputCore_EControllerHand();

	VRGRIPMOTIONCONTROLLERPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPActorGripInformation();
	VRGRIPMOTIONCONTROLLERPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropActor();
	VRGRIPMOTIONCONTROLLERPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GripActor();
	VRGRIPMOTIONCONTROLLERPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_IsTracked();
	VRGRIPMOTIONCONTROLLERPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_PostTeleportMoveGrippedActors();
	VRGRIPMOTIONCONTROLLERPLUGIN_API class UClass* Z_Construct_UClass_UGripMotionControllerComponent_NoRegister();
	VRGRIPMOTIONCONTROLLERPLUGIN_API class UClass* Z_Construct_UClass_UGripMotionControllerComponent();
	VRGRIPMOTIONCONTROLLERPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRGripMotionControllerPlugin();
	UScriptStruct* Z_Construct_UScriptStruct_FBPActorGripInformation()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_VRGripMotionControllerPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FBPActorGripInformation_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("BPActorGripInformation"), sizeof(FBPActorGripInformation), Get_Z_Construct_UScriptStruct_FBPActorGripInformation_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BPActorGripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBPActorGripInformation>, EStructFlags(0x00000001));
			UProperty* NewProp_Actor = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Actor"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Actor, FBPActorGripInformation), 0x0010000000000000, Z_Construct_UClass_AActor_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(NewProp_Actor, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBPActorGripInformation_CRC() { return 1769003006U; }
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropActor()
	{
		struct GripMotionControllerComponent_eventDropActor_Parms
		{
			AActor* ActorToDrop;
			bool bSimulate;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DropActor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(GripMotionControllerComponent_eventDropActor_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventDropActor_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventDropActor_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventDropActor_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSimulate, GripMotionControllerComponent_eventDropActor_Parms, bool);
			UProperty* NewProp_bSimulate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSimulate"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSimulate, GripMotionControllerComponent_eventDropActor_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSimulate, GripMotionControllerComponent_eventDropActor_Parms), sizeof(bool), true);
			UProperty* NewProp_ActorToDrop = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorToDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ActorToDrop, GripMotionControllerComponent_eventDropActor_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Drop a gripped actor"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GripActor()
	{
		struct GripMotionControllerComponent_eventGripActor_Parms
		{
			AActor* ActorToGrip;
			FTransform WorldOffset;
			bool bWorldOffsetIsRelative;
			FName OptionalSnapToSocketName;
			bool bSweepCollision;
			bool bInteractiveCollision;
			bool bAllowSetMobility;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripActor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(GripMotionControllerComponent_eventGripActor_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventGripActor_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventGripActor_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowSetMobility, GripMotionControllerComponent_eventGripActor_Parms, bool);
			UProperty* NewProp_bAllowSetMobility = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAllowSetMobility"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowSetMobility, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bAllowSetMobility, GripMotionControllerComponent_eventGripActor_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInteractiveCollision, GripMotionControllerComponent_eventGripActor_Parms, bool);
			UProperty* NewProp_bInteractiveCollision = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bInteractiveCollision"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInteractiveCollision, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bInteractiveCollision, GripMotionControllerComponent_eventGripActor_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSweepCollision, GripMotionControllerComponent_eventGripActor_Parms, bool);
			UProperty* NewProp_bSweepCollision = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSweepCollision"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSweepCollision, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSweepCollision, GripMotionControllerComponent_eventGripActor_Parms), sizeof(bool), true);
			UProperty* NewProp_OptionalSnapToSocketName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalSnapToSocketName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(OptionalSnapToSocketName, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripActor_Parms, bool);
			UProperty* NewProp_bWorldOffsetIsRelative = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bWorldOffsetIsRelative"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripActor_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldOffset, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_ActorToGrip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorToGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ActorToGrip, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAllowSetMobility"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bInteractiveCollision"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bSweepCollision"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bWorldOffsetIsRelative"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_OptionalSnapToSocketName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip an actor, these are stored in a Tarray that will prevent destruction of the object, you MUST ungrip an actor if you want to kill it\n         The WorldOffset is the transform that it will remain away from the controller, if you use the world position of the actor then it will grab\n         at the point of intersection.\n\n         If WorldOffsetIsRelative is true then it will not convert the transform from world space but will instead use that offset directly.\n         You could pass in a socket relative transform with this set for snapping or an empty transform to snap the object at its 0,0,0 point.\n\n         If you declare a valid OptionSnapToSocketName then it will instead snap the actor to the relative offset\n         location that the socket is to its parent actor."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_IsTracked()
	{
		struct GripMotionControllerComponent_eventIsTracked_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsTracked"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(GripMotionControllerComponent_eventIsTracked_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventIsTracked_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventIsTracked_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventIsTracked_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MotionController"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Whether or not this component had a valid tracked device this frame"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_PostTeleportMoveGrippedActors()
	{
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PostTeleportMoveGrippedActors"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("After teleporting a pawn you NEED to call this, otherwise gripped objects will travel with a sweeped move and can get caught on geometry"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UGripMotionControllerComponent_NoRegister()
	{
		return UGripMotionControllerComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UGripMotionControllerComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage__Script_VRGripMotionControllerPlugin();
			OuterClass = UGripMotionControllerComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_DropActor());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GripActor());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_IsTracked());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_PostTeleportMoveGrippedActors());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseWithoutTracking, UGripMotionControllerComponent, bool);
				UProperty* NewProp_bUseWithoutTracking = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseWithoutTracking"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseWithoutTracking, UGripMotionControllerComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUseWithoutTracking, UGripMotionControllerComponent), sizeof(bool), true);
				UProperty* NewProp_GrippedActors = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GrippedActors"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(GrippedActors, UGripMotionControllerComponent), 0x0010000000000014);
				UProperty* NewProp_GrippedActors_Inner = new(EC_InternalUseOnlyConstructor, NewProp_GrippedActors, TEXT("GrippedActors"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FBPActorGripInformation());
				UProperty* NewProp_CurrentTrackingStatus = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentTrackingStatus"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CurrentTrackingStatus, UGripMotionControllerComponent), 0x0010000000000014, Z_Construct_UEnum_HeadMountedDisplay_ETrackingStatus());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableLowLatencyUpdate, UGripMotionControllerComponent, uint8);
				UProperty* NewProp_bDisableLowLatencyUpdate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDisableLowLatencyUpdate"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableLowLatencyUpdate, UGripMotionControllerComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bDisableLowLatencyUpdate, UGripMotionControllerComponent), sizeof(uint8), false);
				UProperty* NewProp_Hand = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Hand"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Hand, UGripMotionControllerComponent), 0x0010000000000005, Z_Construct_UEnum_InputCore_EControllerHand());
				UProperty* NewProp_PlayerIndex = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PlayerIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(PlayerIndex, UGripMotionControllerComponent), 0x0010000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_DropActor(), "DropActor"); // 4181557680
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GripActor(), "GripActor"); // 2411221948
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_IsTracked(), "IsTracked"); // 1675797175
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_PostTeleportMoveGrippedActors(), "PostTeleportMoveGrippedActors"); // 1247750312
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("MotionController"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Trigger ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GripMotionControllerComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bUseWithoutTracking, TEXT("Category"), TEXT("VRGrip"));
				MetaData->SetValue(NewProp_bUseWithoutTracking, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bUseWithoutTracking, TEXT("ToolTip"), TEXT("This is for testing, setting it to true allows you to test grip with a non VR enabled pawn"));
				MetaData->SetValue(NewProp_GrippedActors, TEXT("Category"), TEXT("VRGrip"));
				MetaData->SetValue(NewProp_GrippedActors, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_CurrentTrackingStatus, TEXT("Category"), TEXT("MotionController"));
				MetaData->SetValue(NewProp_CurrentTrackingStatus, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_CurrentTrackingStatus, TEXT("ToolTip"), TEXT("The tracking status for the device (e.g. full tracking, inertial tracking only, no tracking)"));
				MetaData->SetValue(NewProp_bDisableLowLatencyUpdate, TEXT("Category"), TEXT("MotionController"));
				MetaData->SetValue(NewProp_bDisableLowLatencyUpdate, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bDisableLowLatencyUpdate, TEXT("ToolTip"), TEXT("If false, render transforms within the motion controller hierarchy will be updated a second time immediately before rendering."));
				MetaData->SetValue(NewProp_Hand, TEXT("Category"), TEXT("MotionController"));
				MetaData->SetValue(NewProp_Hand, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_Hand, TEXT("ToolTip"), TEXT("Which hand this component should automatically follow"));
				MetaData->SetValue(NewProp_PlayerIndex, TEXT("Category"), TEXT("MotionController"));
				MetaData->SetValue(NewProp_PlayerIndex, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_PlayerIndex, TEXT("ToolTip"), TEXT("Which player index this motion controller should automatically follow"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UGripMotionControllerComponent(Z_Construct_UClass_UGripMotionControllerComponent, &UGripMotionControllerComponent::StaticClass, TEXT("UGripMotionControllerComponent"), false, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UGripMotionControllerComponent);
	UPackage* Z_Construct_UPackage__Script_VRGripMotionControllerPlugin()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/VRGripMotionControllerPlugin")), false, false));
			ReturnPackage->SetPackageFlags(PKG_CompiledIn | 0x00000000);
			FGuid Guid;
			Guid.A = 0x77D74D63;
			Guid.B = 0xA78DF278;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
